 # 构建RAG系统以实现Word和Excel表格的精准解析与检索





## 执行摘要



本报告旨在提出一个用于文档和表格检索的优化RAG（Retrieval-Augmented Generation）架构，以解决从Word和Excel文档中准确解析、存储和检索信息，特别是表格数据所面临的挑战。该架构强调了`python-docx`、`Pandas`、Weaviate以及先进大型语言模型（LLM）技术在语义丰富和上下文理解方面的整合。

核心建议是采用一种混合方法，包括Markdown格式的表格存储、多粒度向量化（整表、行级和描述性元数据）以及在Weaviate中利用其混合搜索能力实现的复杂上下文链接（父子分块）。这种方法旨在弥合表格数据与LLM理解之间的语义鸿沟，确保解析、存储和向量化阶段的紧密互联，从而实现精准检索。

为实现最优检索和LLM集成，本报告推荐以下关键策略：利用Markdown作为LLM友好的表格表示格式，生成丰富的表格描述，采用混合向量化策略，并实施鲁棒的上下文链接机制。这些措施共同作用，旨在提升RAG系统处理复杂文档的能力，特别是那些包含非结构化文本和半结构化表格数据的文档。



## 理解RAG系统挑战：文档与表格集成





### 定义精准信息检索的范围与目标



构建一个能够从Word和Excel文档中的非结构化文本和半结构化表格数据中精确检索信息的RAG系统是本项目的核心目标。这对于为LLM提供准确、上下文相关且细粒度的数据至关重要，尤其是在处理跨文本和表格的复杂查询时，例如分析财务报告或技术规范。表格数据固有的复杂结构、对上下文的依赖性以及查询的模糊性，是构建此类系统时必须克服的固有难题。本报告旨在提供克服这些挑战的策略，以确保最终系统能够满足对“精准检索”的需求。



### 表格数据在RAG系统中的挑战



表格数据在RAG系统中带来了多重固有挑战，这些挑战源于其独特的结构和语义特性。

首先，**结构复杂性**是主要障碍。表格具有固有的二维结构，包含行、列和表头，这与传统的线性文本分块方法格格不入。简单地将表格数据视为连续文本会丢失其内部的结构化关系，从而影响后续的理解和检索。

其次，**上下文依赖性**至关重要。表格的含义往往严重依赖于周围的文本、标题，甚至其他表格。孤立地检索表格可能导致误解或信息不完整。例如，一份财务报表中的数字，如果没有其所属的季度或年份信息，其意义将大打折扣。

第三，**LLM解释能力**是关键考量。原始表格数据（例如CSV格式或二维数组）通常难以被LLM直接有效解释。LLM在处理自然语言或结构化文本格式（如Markdown）时表现更佳。这不仅仅是格式问题，更是一个根本性的“语义鸿沟”。LLM在大量自然语言文本上进行训练，使其擅长处理句子和段落。相比之下，表格通过空间排列和隐式上下文线索（如列标题）传达关系和数据点。直接将二维数组或CSV字符串输入LLM通常会丢失这种关系上下文，导致解释不佳。因此，挑战不仅在于如何存储表格，更在于如何以LLM能够有效“阅读”和推理的自然语言式格式来表示其固有的结构和关系。这意味着所选的存储格式必须充当桥梁，将表格结构转化为语义丰富的文本表示。

第四，**检索粒度**是一个重要的设计决策。决定是检索整个表格、特定行，甚至是单个单元格，都会直接影响RAG系统的精度和召回率。过于粗糙的粒度可能导致检索到不必要的冗余信息，而过于细致的粒度则可能丢失整体上下文。

最后，**查询模糊性**增加了复杂性。用户查询可能隐式地引用表格内容，而没有明确提及表格，这需要复杂的语义理解和查询扩展能力。例如，用户可能询问“公司成本”，而表格中仅列出了“支出”和“收入”，这就要求系统能够将查询与表格的潜在语义内容进行匹配。

这些挑战共同指向一个核心问题：解析、存储和向量化阶段的相互依赖性对于检索精度至关重要。用户提出“精准检索”的目标，并将问题分解为解析、结构化、向量化和上下文集成。研究表明，这些阶段并非独立存在。一个糟糕的解析策略（例如，遗漏表格标题）将导致糟糕的存储（例如，缺少元数据），进而导致无效的向量化（例如，向量缺乏关键语义信息），最终严重损害检索精度。例如，如果表格标题 在解析时未被提取并整合到分块的元数据或描述中，那么随后的向量化将缺乏这些关键关键词，使得基于列内容的精确检索变得非常困难。这表明需要一个整体设计，其中一个阶段的决策直接影响并优化后续阶段，而不是将它们视为孤立的步骤。



## 阶段1：鲁棒的文档解析与表格提取





### 利用`python-docx`解析Word文档



对于Word文档的解析，`python-docx`是指定的库，它允许以编程方式访问文档元素，包括段落、运行和表格。

**文本和表格识别策略：**

- 通过迭代`document.paragraphs`来提取叙述性文本。
- 通过迭代`document.tables`来提取表格数据。每个表格都可以作为`Table`对象访问，其行和单元格可以被迭代以提取内容。
- **预处理：** 在存储之前，表格数据应进行清洗和标准化处理，例如处理合并单元格、不一致的格式和空单元格。这一步骤对于确保数据质量至关重要，因为任何解析错误或遗漏都将向下游传播，影响后续的向量化和LLM解释。



### 利用`Pandas`处理Excel工作簿



`Pandas`是处理Excel文件中的表格数据的指定库，其在读取和操作方面表现出色。

**处理多样化的工作表结构和数据类型：**

- `pd.read_excel()`函数能够读取特定工作表、范围，并处理各种数据类型。
- 识别工作表中的实际数据范围至关重要，因为Excel文件通常包含元数据、多个表格或非数据元素。这可能需要启发式方法或用户定义的配置。
- 需要考虑合并单元格、隐藏行/列以及每个工作表中的多个表格等潜在问题，这些都需要在Pandas中进行仔细的预处理。



### 表格数据表示与初始结构化策略



表格数据的表示选择对LLM的可解释性和向量化效果产生深远影响。用户明确询问：“输出二维数组？或者markdown表格格式？或者拆成单行？”

- **选项1：二维数组（例如，列表的列表或Pandas DataFrame）：**
  - **优点：** 保留原始结构，便于程序化操作，可直接从`python-docx`表格迭代或`Pandas`中输出。
  - **缺点：** LLM直接解释效果不佳。需要转换为LLM输入格式。不适合作为原始字符串进行向量化。
- **选项2：Markdown表格格式：**
  - **优点：** LLM高度可读。以文本形式保留表格结构。相对容易从二维数组/DataFrames生成。适合检索后直接作为LLM输入。
  - **缺点：** 对于非常大的表格可能会变得冗长。可能会丢失一些复杂的格式信息（例如，单元格颜色、特定边框）。
- **选项3：按行（每行一个分块）：**
  - **优点：** 粒度高，可能适合特定行级查询。可以与列标题结合以提供上下文（例如，“公司A，第一季度利润：1000万美元”）。
  - **缺点：** 如果不进行链接，会丢失整体表格上下文。可能导致大量小分块，增加向量数据库大小并可能增加检索开销。

推荐的初始结构化方法：

对于初始解析，将数据保留为Pandas DataFrame（用于Excel）或列表的列表（用于Word表格），因为这是最鲁棒的程序化表示。然而，对于LLM输入和向量化，强烈推荐使用Markdown格式作为表格分块内容的主要表示形式。这直接解决了用户关于“大模型能不能准确识别”的担忧。为了实现更精细的检索，本报告将在第二阶段探讨存储整表Markdown和单独的基于行的分块（并进行上下文丰富）的混合方法。

在解析阶段，存在一个“解析粒度与上下文保留”的权衡。当解析时，我们可以将表格作为一个整体（二维数组/DataFrame）提取，或者将其分解为独立的行。虽然提取整个表格保留了其固有的结构和上下文，但它可能对于单个向量嵌入来说过大，或者对于高度特定的查询来说过于粗糙。相反，将其分解为独立的行（甚至单元格）提供了高粒度，但有丢失整体表格上下文（例如，表格是关于什么的）的风险，并可能创建大量语义不那么丰富的小分块。这里的“最优”解决方案并非单一选择，而是基于预期检索粒度的战略决策。如果用户主要询问“第一季度利润是多少？”，那么一个包含“第一季度利润”的行级分块可能是理想的。但如果他们询问“总结公司的财务表现”，则需要整个表格。这表明解析阶段需要预见向量化和检索阶段的需求，可能需要生成同一表格数据的多种表示形式。

此外，预处理的必要性对于下游的成功至关重要。研究表明 提到“清洗和标准化表格数据”。这看似显而易见，但其影响是深远的。如果解析步骤未能准确识别标题、处理合并单元格或标准化数据类型（例如，将数字存储为字符串），那么所有后续步骤——存储、向量化和LLM解释——都将受到损害。例如，如果一个表格的某个类别有合并单元格，并且解析器未能将该类别正确传播到所有相关行，那么行级嵌入将是不完整的，LLM将难以理解该行的完整上下文。这突显了原始数据提取和初始结构化质量是整个RAG系统准确性的基石。此处的任何错误或遗漏都将级联并放大，使得“精准检索”无法实现。



## 阶段2：表格数据的最优存储与向量化





### 表格存储格式的比较分析



目标是以一种既可向量化又可在检索后被LLM解释的方式将数据存储在Weaviate中。

- **Markdown表格格式：**
  - **优点：** 对LLM的解释性极佳。保留结构。人类可读。可直接嵌入。
  - **缺点：** 对于大型表格可能冗长。如果没有额外的元数据，可能不适合非常具体的单元格级检索。
  - **建议：** 作为表格分块内容的主要格式。
- **JSON/字典格式（结构化数据）：**
  - **优点：** 机器可读，允许附加丰富的元数据。可转换为Markdown或自然语言供LLM使用。
  - **缺点：** 如果不进行转换，对LLM不直接友好。在Weaviate中需要仔细的Schema设计。
  - **建议：** 用于存储元数据（例如，表格ID、源文档、页码、关联文本分块ID）以及可能与Markdown等效的每行的结构化表示。
- **纯文本（例如，CSV字符串）：**
  - **优点：** 易于生成。
  - **缺点：** LLM解释性差。丢失结构线索。
  - **避免直接作为LLM输入。**

下表提供了不同表格存储格式的比较分析：

| 格式               | 优点                            | 缺点                                     | LLM解释性 | 检索适用性                                 |
| ------------------ | ------------------------------- | ---------------------------------------- | --------- | ------------------------------------------ |
| 二维数组/DataFrame | 保留原始结构，便于程序化操作    | LLM直接解释差，需转换                    | 差        | 适合程序化处理，不直接用于语义检索         |
| Markdown表格格式   | LLM高度可读，保留结构，人类可读 | 大型表格可能冗长，可能丢失复杂格式       | 优        | 适合语义检索，直接作为LLM输入              |
| 行级文本           | 粒度高，适合特定行级查询        | 易丢失整体表格上下文，可能产生大量小分块 | 良好      | 适合细粒度查询，需结合上下文               |
| JSON/字典格式      | 机器可读，支持丰富元数据        | LLM不直接友好，需转换，需仔细Schema设计  | 差        | 适合元数据存储和结构化查询，需配合其他格式 |



### 表格数据的高级向量化策略



用户询问：“整表向量、单行向量、加描述一起向量、仅描述/关键词向量？”

- **策略1：整表向量化（Markdown字符串）：**
  - **方法：** 将整个表格转换为Markdown字符串并为其生成单个嵌入。
  - **优点：** 捕获整体表格上下文。适用于关于表格主题的高级查询。
  - **缺点：** 对于特定单元格/行查询精度较低。大型表格可能导致粒度较低的嵌入。
- **策略2：行级向量化（丰富文本）：**
  - **方法：** 将每行转换为描述性句子或短段落，可能包括列标题和表格标题/描述，然后进行嵌入。例如，“在财务报表中，第一季度利润为1000万美元，成本率为20%。”
  - **优点：** 粒度更高，更适合特定数据点检索。
  - **缺点：** 可能导致大量分块。需要仔细构建描述性句子以保留上下文。
- **策略3：混合向量化（表格+描述/关键词）：**
  - **方法：** 这是推荐的“最优”方法。
    - **主分块：** 整个表格以Markdown形式表示，并附带生成的摘要/描述。此分块捕获整体上下文，适用于高级查询。
    - **次分块：** 单独的行，通过各自的列标题 和可能包含父表格摘要进行丰富，也转换为描述性句子/Markdown片段。这些分块与主分块链接（父子关系）。
    - **元数据：** 存储附加元数据，如原始文档ID、页码、表格标题、源文本上下文和提取的关键词。这些元数据可用于Weaviate中的关键词搜索或过滤。
  - **优点：** 结合了整表上下文和行级粒度的优势。提高了检索精度和召回率。允许进行多方面查询。
  - **缺点：** 分块和索引的复杂性增加。需要更多存储空间。
- **策略4：专用表格嵌入模型：**
  - **方法：** 探索Table-BERT或其他基于图的表格嵌入技术等模型。
  - **优点：** 在捕获表格语义方面可能表现更优。
  - **缺点：** 可能需要专用基础设施或更复杂的集成。

用户对“表格数据怎么加工？比如为这个表格添加描述？还是直接向量？整表向量、单行向量、加描述一起向量、仅描述/关键词向量？”的询问，可以通过下表进行系统性回答：

| 策略             | 方法描述                                                     | 优点                                     | 缺点                             | 最佳用例                         | 推荐度 |
| ---------------- | ------------------------------------------------------------ | ---------------------------------------- | -------------------------------- | -------------------------------- | ------ |
| 整表向量化       | 将整个表格转换为Markdown字符串并生成单个嵌入                 | 捕获整体上下文，适用于高层级查询         | 细节查询精度低，大型表格粒度粗   | 总结性查询，表格主题识别         | 中     |
| 行级向量化       | 每行转换为描述性句子（含标题、描述），然后嵌入               | 粒度高，适合特定数据点检索               | 产生大量分块，易丢失整体上下文   | 细节查询，特定数据点查找         | 中     |
| 混合向量化       | 主分块（整表Markdown+描述），次分块（丰富行级文本），并建立父子链接 | 结合整表上下文和行级粒度，提高精度和召回 | 分块和索引复杂性增加，存储需求高 | 综合性查询，需同时兼顾概览与细节 | **高** |
| 专用表格嵌入模型 | 使用如Table-BERT等专门为表格设计的嵌入模型                   | 更擅长捕获表格语义                       | 可能需要专用基础设施和复杂集成   | 复杂表格结构，深层语义理解       | 探索性 |



### 通过关键词提取和语义丰富增强查询能力



- **关键词提取：** 自动从表格标题、单元格内容和生成的描述中提取关键词。这些关键词可以作为元数据存储在Weaviate中。
- **语义丰富/描述生成：** 使用LLM为每个表格（）以及可能为每个行级分块生成简洁的自然语言描述或摘要。这些描述显著提高了表格通过语义搜索的可发现性，尤其当查询不直接匹配表格内容，而是其隐含意义时（例如，对于列出“公司成本，营收”的表格，查询“财务数据”）。
- **查询扩展/重写：** 在查询Weaviate之前，使用LLM扩展或重写用户查询，加入同义词、相关术语或推断意图。这可以包括添加关键词或生成语义更丰富的查询嵌入。
- **Weaviate中的混合搜索：** 利用Weaviate执行混合搜索（向量搜索+关键词搜索）的能力。这通过结合语义相似性和元数据的精确关键词匹配，实现了高度精确的检索。

多粒度分块对于平衡检索至关重要。用户对“精准检索”的需求，以及对不同查询类型（例如，“亏损原因，给出详细清单”与“公司成本，营收”）的响应，不能通过单一的分块策略来满足。如果只存储整个表格，那么精确的细节查询将难以回答。如果只存储行，表格的整体上下文就会丢失，使得总结性问题变得困难。研究表明 强调了不同粒度之间的权衡。这里的关键在于，一个针对表格的优化RAG系统必须采用多粒度分块策略。这意味着既要创建整表分块（用于广泛上下文和摘要查询），又要创建更细粒度的行级分块（用于特定细节查询），并明确它们之间的链接。这使得检索系统能够根据查询意图获取最适当的细节级别，从而实现更平衡和有效的RAG系统。

此外，元数据作为“语义粘合剂”对于增强检索至关重要。研究指出 添加元数据（来源、页码、上下文摘要）， 指出表格标题是很好的关键词， 建议生成描述。更深层次的认识是，这些元数据不仅仅是辅助信息；它们是显著增强检索的“语义粘合剂”。通过嵌入表格的描述（由LLM生成）或关键词（来自标题）及其内容，向量空间变得更加丰富。像“财务数据”这样的查询（表格中没有这个词）现在可以语义上匹配一个其描述包含“财务数据”或其标题暗示财务内容的表格。这超越了简单的关键词匹配，实现了真正的语义理解，使得即使对于抽象查询也能实现“精准检索”。此外，元数据在Weaviate中实现了强大的过滤和混合搜索，通过结合向量相似性与结构化属性过滤，实现了高度目标化的检索。



## 阶段3：上下文集成以增强检索





### 将表格数据与周围叙述性内容链接



用户提供的上市公司年报示例，其中大段文字描述公司财务状况和亏损原因，随后是一个仅列出支出、收入和净收入的完整表格数据，直接突出了这种上下文关联的需求。

- **父子分块策略：**
  - **方法：** 表格周围的叙述性文本应单独分块，但与表格分块链接。表格本身可以被视为周围“父”文本分块（例如，介绍表格或讨论其内容的段落）的“子”分块。
  - **实现：** 在Weaviate的Schema中存储引用（例如，`parent_chunk_id`、`child_table_ids`）。当检索到表格时，其父上下文也可以被获取，反之亦然。
- **交叉引用和标注：**
  - 明确将表格ID链接到相关的文本分块，反之亦然。
  - 在解析过程中，识别介绍或引用表格的句子或段落。这些“上下文锚点”可以用于丰富表格的元数据，或作为表格嵌入的一部分。



### 上下文向量化与检索策略



- **组合嵌入：**
  - **方法：** 通过连接表格的Markdown表示及其周围上下文的摘要（例如，父文本分块的摘要或介绍性句子）来生成表格的嵌入。
  - **优点：** 表格的向量现在固有地携带其上下文含义，允许与上下文相关的查询检索到表格。
  - **缺点：** 如果上下文过长，可能使分块变大，从而稀释表格特定的语义。
- **多向量检索：**
  - **方法：** 为表格（Markdown）、其描述性摘要和其周围文本上下文存储单独的向量。在检索时，查询所有相关向量。
  - **优点：** 提供灵活性。关于“亏损原因”的查询可能首先检索到讨论该问题的文本分块，然后通过父子链接指向相关表格。
  - **推荐：** 这种方法，结合父子分块，是最佳选择。当查询命中一个文本分块时，RAG系统可以检索相关的表格；当命中一个表格时，它可以检索其周围的文本上下文。
- **上下文感知的语义搜索：**
  - 利用Weaviate中组合嵌入和链接分块的能力，执行理解文本和表格之间关系的语义搜索。
  - **示例：** 像“亏损原因，给出详细清单”这样的查询，理想情况下会：
    1. 语义上匹配讨论“亏损原因”的文本。
    2. 从该文本通过父子链接追踪到相关的财务表格。
    3. 检索表格（以Markdown格式）并呈现给LLM。

用户示例“亏损原因，给出详细清单”完美地说明了“隐式查询到表格映射”的问题。用户询问一个在文本中描述的概念（“亏损原因”），但详细清单却在表格中。如果没有明确的上下文链接，RAG系统很可能只检索到文本，而错过了关键的表格。研究指出 共同指向解决方案：父子分块和组合嵌入。这里的关键在于，系统必须被设计为能够推断出基于文本的查询可能需要表格数据，反之亦然。这通过在文本和表格分块之间创建明确的关系（链接）和语义重叠（组合嵌入）来实现，从而有效地允许检索过程根据语义相关性“弥合”不同信息模式之间的差距。

除了检索正确的数据，RAG系统还需要以一种允许LLM生成连贯回答的方式提供数据。如果表格被孤立地检索，LLM可能难以将其无缝地整合到叙述性回答中。通过上下文集成（父子分块、组合嵌入）保留“叙述流”，LLM不仅接收到表格，还接收到解释其目的、上下文和相关性的周围文本。这使得LLM能够生成更准确、全面和类人的回答，因为它根据表格在原始文档中的位置理解了该表格与查询相关的原因。例如，如果检索到一个详细列出费用的表格，但LLM也收到前面讨论“为降低运营成本所采取的措施”的段落，它就能比仅提供表格生成更具洞察力的回答。



## 拟议最优RAG架构与数据流





### 高层系统概述



以下图示描绘了从文档摄取到LLM响应的端到端流程：

代码段

```
graph TD
    A[文档摄取] --> B{解析层};
    B -- Word --> C[python-docx];
    B -- Excel --> D[Pandas];
    C --> E[预处理];
    D --> E;
    E --> F{分块与结构化层};
    F -- 文本 --> G[文本分块];
    F -- 表格 --> H[表格分块<br>(整表+行级)];
    G --> I[上下文链接<br>(父子关系)];
    H --> I;
    I --> J{元数据生成与丰富层};
    J --> K[表格描述/摘要];
    J --> L[关键词提取];
    J --> M[一般元数据];
    K --> N{向量化层};
    L --> N;
    M --> N;
    N --> O[嵌入模型];
    O --> P{向量数据库<br>(Weaviate)集成};
    P --> Q;
    P --> R[索引];
    Q --> S{检索层};
    R --> S;
    S -- 用户查询 --> T[查询扩展/重写];
    S -- Weaviate --> U[混合搜索];
    U --> V[上下文检索];
    V --> W[重排序];
    W --> X{生成层<br>(LLM)};
    X --> Y[上下文组装];
    Y --> Z[LLM提示];
    Z --> AA[LLM响应];
```



### 推荐系统的详细蓝图



**1. 文档摄取与解析层：**

- **Word文档：** 利用`python-docx`提取文本段落和表格。每个表格初步解析为Pandas DataFrame。
- **Excel工作簿：** 利用`Pandas` (`pd.read_excel`) 识别并从工作表中提取表格。
- **预处理：** 清洗和标准化提取的表格数据。识别表格标题。

**2. 分块与结构化层：**

- **文本分块：** 将叙述性文本分割成语义连贯的分块（例如，段落级或固定大小带重叠的分块）。
- **表格分块（多粒度）：**
  - **整表分块：** 将整个表格DataFrame转换为Markdown字符串。
  - **行级分块：** 为每行创建描述性句子或短Markdown片段，包含列标题和父表格上下文。
- **上下文链接（父子关系）：** 在文本分块和它们引用的表格之间，以及整表分块和它们的行级子分块之间建立明确的链接。将这些关系作为元数据存储。

**3. 元数据生成与丰富层：**

- **表格描述/摘要：** 使用LLM为每个表格以及可能为每个行级分块生成简洁、语义化的描述。
- **关键词提取：** 从表格内容、标题和描述中提取关键词。
- **一般元数据：** 捕获文档ID、页码、章节和原始文件路径。

**4. 向量化层：**

- **嵌入模型：** 选择一个鲁棒的嵌入模型（例如，经过微调的Sentence-BERT变体或在资源允许的情况下使用专用表格嵌入模型）。
- **嵌入过程：**
  - 为文本分块生成嵌入。
  - 为整表Markdown字符串（与描述连接）生成嵌入。
  - 为丰富后的行级文本生成嵌入。
  - 考虑将表格内容与周围文本结合以生成上下文嵌入。

**5. 向量数据库（Weaviate）集成：**

- **Schema设计：** 在Weaviate中定义一个全面的Schema 以存储：
  - `text`（用于文本分块、整表Markdown、行级文本）
  - `metadata`（例如，`doc_id`、`page_num`、`chunk_type`（text/table/row）、`table_id`、`parent_chunk_id`、`child_chunk_ids`、`keywords`、`description`）
  - `vector`（嵌入）
- **索引：** 将所有分块及其关联的元数据和向量摄取到Weaviate中。

**6. 检索层：**

- **查询扩展/重写：** 使用LLM重新措辞或扩展用户查询，以实现更好的语义匹配。
- **混合搜索：** 在Weaviate中执行混合搜索，结合向量相似性搜索和元数据上的关键词过滤。
- **上下文检索：** 如果检索到文本分块，也通过父子链接获取其关联的表格。如果检索到表格/行，也获取其周围的文本上下文。
- **重排序：** 根据额外的相关性分数或基于LLM的重排序，对检索到的分块进行潜在的重排序。

**7. 生成层（LLM）：**

- **上下文组装：** 将检索到的文本和表格分块（以Markdown格式）组装成LLM的连贯上下文窗口。确保上下文尽可能保留原始文档的流程。
- **LLM提示：** 使用用户查询和组装好的上下文提示LLM，以生成全面的回答。

下表总结了拟议最优RAG架构的关键组件及其在整个系统中的作用：

| 组件/层          | 关键技术/工具           | 主要功能                           | 输入/输出                            | 关键考量                                   |
| ---------------- | ----------------------- | ---------------------------------- | ------------------------------------ | ------------------------------------------ |
| 文档摄取与解析   | `python-docx`, `Pandas` | 从Word/Excel提取文本和表格         | Word/Excel文件 -> DataFrame/文本     | 数据清洗，标题识别，处理复杂结构           |
| 分块与结构化     | 自定义逻辑              | 将数据分块并建立内部关系           | DataFrame/文本 -> 文本/表格/行级分块 | 多粒度分块，父子链接，上下文保留           |
| 元数据生成与丰富 | LLM, 关键词提取器       | 为分块生成描述、关键词和通用元数据 | 各类分块 -> 丰富元数据               | LLM生成质量，关键词准确性                  |
| 向量化           | 嵌入模型                | 为分块内容及其元数据生成向量嵌入   | 文本/Markdown/丰富文本 -> 向量       | 嵌入模型选择，组合嵌入策略                 |
| Weaviate集成     | Weaviate                | 存储向量和元数据，管理数据关系     | 向量、元数据 -> Weaviate Schema/索引 | Schema设计，关系建模，索引优化             |
| 检索             | LLM, Weaviate           | 根据查询检索最相关的分块           | 用户查询 -> 相关分块 (文本/表格)     | 查询扩展，混合搜索，上下文感知检索，重排序 |
| 生成             | LLM                     | 根据检索到的上下文生成最终回答     | 相关分块 -> LLM回答                  | 上下文组装，提示工程，回答的准确性与连贯性 |

Weaviate在其中扮演着“语义知识图谱”的角色。用户指定了Weaviate，并且研究强调了Schema设计 和Weaviate的能力。Weaviate不仅仅是一个向量存储，它的面向对象Schema以及定义对象之间关系的能力（例如，文本分块`HAS_TABLE`表格分块，表格分块`HAS_ROW`行分块）使其能够充当“语义知识图谱”。这对于处理已识别的复杂上下文关系（父子、表格-文本交叉引用）至关重要。通过在Schema中明确建模这些关系，检索变得比简单的向量搜索强大得多。查询可以遍历这些关系，允许系统不仅检索匹配的分块，还检索其整个相关上下文，这对于向LLM提供全面回答至关重要。

此外，语义丰富化的“反馈循环”对于持续改进至关重要。拟议的架构严重依赖LLM进行语义丰富（表格描述、查询扩展）。这形成了一个强大的反馈循环。随着系统的使用和评估（第七阶段），LLM生成的描述和扩展查询的质量可以得到评估。检索性能不佳可能表明描述不够丰富或查询扩展无效。这些数据可以用于微调负责这些丰富任务的LLM模型，从而持续改进整个RAG系统的准确性和“精准检索”能力。这将系统从静态管道转变为自适应、学习型系统。



## 评估框架与关键绩效指标





### 测试和验证检索准确性的度量和方法



为了确保RAG系统的有效性，需要一个全面的评估框架，涵盖检索和生成两个方面。

**检索指标：**

- **准确率（Precision）、召回率（Recall）、F1分数：** 用于评估检索到的相关分块数量以及包含的无关分块数量。
- **平均倒数排名（MRR）：** 适用于排名检索结果。
- **命中率/Recall@k：** 评估正确分块是否在检索到的前k个结果中。

**LLM性能指标：**

- **忠实度/事实性：** LLM的回答是否与检索到的上下文一致？
- **相关性：** LLM的回答是否与查询相关？
- **连贯性/流畅性：** 回答是否书写良好且易于理解？
- **完整性：** 回答是否涵盖了查询的所有方面，特别是与表格相关的问题？
- **人工评估：** 对于LLM生成答案的主观质量评估至关重要。



### 测试数据准备



- 创建包含表格的Word和Excel文档的多样化数据集。
- 开发一组代表性查询，包括：
  - 直接表格内容查询（例如，“第三季度利润是多少？”）。
  - 跨文本和表格的上下文查询（例如，“亏损的原因是什么，请从财务报表中提供详细信息？”）。
  - 需要语义推断的查询（例如，“总结公司的财务状况”）。
- 为每个查询手动标注真实答案和相关的文档分块。



### 不同策略的A/B测试



系统地比较不同的表格存储格式（Markdown与二维数组作为LLM输入）、向量化策略（整表与行级与混合）和上下文链接方法，以量化它们对检索和LLM性能的影响。

RAG系统的“整体评估”至关重要。用户的最终目标是RAG系统的“最优方案”。研究提到了检索指标。然而，对于RAG系统而言，仅评估检索是不够的。一个系统可能完美地检索，但如果LLM无法解释检索到的数据（例如，原始二维数组表格），则最终用户体验会很差。这里的关键在于，评估必须是整体性的，既要包括检索准确性（我们是否获得了正确的分块？），又要包括生成质量（LLM是否有效地利用分块来真实、连贯地回答查询？）。这意味着需要能够连接这两个组件的指标，例如RAG特有的指标（例如，RAGAS框架中的忠实度和回答相关性）以及直接评估端到端用户体验的人工评估。

此外，评估驱动的“迭代优化”循环是持续改进的关键。构建“最优”RAG系统的过程并非线性，而是迭代的。上述详细的评估框架不仅仅是最终检查；它是一个持续的反馈机制。如果初步测试显示上下文查询的召回率较低，则表明需要改进父子分块或上下文嵌入策略。如果LLM输出经常出现幻觉或误解表格，则表明表格表示（例如，更多地转向Markdown）或LLM提示存在问题。这意味着评估阶段必须与开发生命周期紧密集成，推动对解析、存储、向量化和上下文集成策略的连续改进和优化。



## 结论与未来考虑





### 关键建议总结



为实现Word和Excel文档中表格数据的精准解析与检索，本报告推荐采用以下最优RAG系统方案：

- **混合表格表示：** 采用Markdown格式存储表格内容以提高LLM的可解释性，同时使用JSON格式存储丰富的元数据，以便于机器处理和结构化查询。
- **多粒度向量化：** 结合整表向量化（用于捕获整体上下文和高级查询）、行级向量化（用于实现细粒度数据点检索）以及通过LLM生成的丰富描述进行向量化，以增强语义匹配能力。
- **父子上下文链接：** 在文本分块与相关表格之间、以及整表与行级分块之间建立明确的父子关系，确保在检索时能够获取完整的上下文信息。
- **Weaviate的混合搜索：** 充分利用Weaviate的向量相似性搜索和关键词过滤能力，实现高效且精准的混合检索。
- **鲁棒的预处理和LLM驱动的语义丰富：** 强调在数据摄取阶段进行彻底的清洗和标准化，并通过LLM生成表格描述和关键词，以弥合表格数据与LLM理解之间的语义鸿沟，从而显著提升检索效果。



### 未来增强



RAG系统的发展是一个持续优化的过程。以下是未来可能探索的增强方向：

- **微调LLM以处理表格数据：** 探索对小型LLM进行微调，使其专门用于表格摘要、描述生成，甚至直接的表格问答任务，以提高其在表格理解方面的专业能力。
- **基于图的表格表示：** 研究更先进的基于图的表格表示方法，以更丰富地捕获表格内部的语义关系和结构，从而进一步提升检索和推理能力。
- **高级查询理解：** 实施更复杂的查询意图分类机制，根据用户查询的性质动态调整检索策略（例如，如果查询高度具体，则优先考虑行级分块）。
- **用户反馈集成：** 开发捕获用户对回答质量反馈的机制，并将这些反馈数据用于进一步优化系统，形成一个持续学习和改进的闭环。
- **自动化数据标注：** 探索半自动化或自动化方法来生成地面真值（ground truth）标注，以扩大评估数据集的规模，从而更全面地测试和验证系统性能。

这些未来的考虑旨在进一步提升RAG系统在处理复杂文档和表格数据方面的能力，使其能够提供更智能、更准确、更全面的信息检索和生成服务。